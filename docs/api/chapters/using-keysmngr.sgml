<sect1 id="xmlsec-notes-keysmngr">
    <title>Keys manager.</title>
    <para>Processing some of the key data objects require additional 
	information which is global across the application (or in the 
	particular area of the application). For example, X509 certificates 
	processing require a common list of trusted certificates to be 
	available. XML Security Library keeps all the common information 
	for key data processing in a a collection of key data stores called 
	"keys manager".
    </para>
    <figure>
	<title>The keys manager structure.</title>
	<graphic fileref="images/keysmngr.png" align="center" />
    </figure>	 
    <para>Keys manager has a special "keys store" which lists the keys 
	known to the application. This "keys store" is used by XML Security 
	Library to lookup keys by name, type and crypto algorithm (for example,
	during 
    	<ulink URL="http://www.w3.org/TR/xmldsig-core/#sec-KeyName">&lt;dsig:KeyName/&gt;</ulink>
	processing). The XML Security Library 
	provides default "flat list" based implementation of a simple keys 
	store. The application can replace it with any other keys store 
	(for example, based on an SQL database).
    </para>
    <para>Keys manager is the only object in XML Security Library which 
	is supposed to be shared by many different operations. Usually keys 
	manager is initialized once at the application startup and later is 
	used by XML Security library routines in "read-only" mode. If 
	application or crypto function need to modify any of the key data 
	stores inside keys manager then proper synchronization must be 
	implemented. In the same time, application can create a new keys 
	manager each time it needs to perform XML signature, verification, 
	encryption or decryption.
    </para>
	
    <sect2>
	<title>Simple keys store.</title>
	<para>XML Security Library has a built-in simple keys store 
	implemented using a keys list. You can use it in your application
	if you have a small number of keys. However, this might be not a 
	best option from performance point of view if you have a lot of keys.
	In this case, you probably should implement your own keys store
	using an SQL database or some other keys storage.
	</para>
	<para>
	     <example>
		<title>Initializing keys manager and loading public keys from PEM files.</title>
		<programlisting><![CDATA[
/**
 * load_public_keys:
 * @files:		the list of filenames.
 * @files_size:		the number of filenames in #files.
 *
 * Creates simple keys manager and load public keys from #files in it.
 * The caller is responsible for destroing returned keys manager using
 * @xmlSecKeysMngrDestroy.
 *
 * Returns the pointer to newly created keys manager or NULL if an error
 * occurs.
 */
xmlSecKeysMngrPtr 
load_public_keys(char** files, int files_size) {
    xmlSecKeysMngrPtr mngr;
    xmlSecKeyPtr key;
    int i;
    
    assert(files);
    assert(files_size > 0);
    
    /* create and initialize keys manager, we use a simple list based
     * keys manager, implement your own xmlSecKeysStore klass if you need
     * something more sophisticated 
     */
    mngr = xmlSecKeysMngrCreate();
    if(mngr == NULL) {
	fprintf(stderr, "Error: failed to create keys manager.\n");
	return(NULL);
    }
    if(xmlSecCryptoAppSimpleKeysMngrInit(mngr) < 0) {
	fprintf(stderr, "Error: failed to initialize keys manager.\n");
	xmlSecKeysMngrDestroy(mngr);
	return(NULL);
    }    
    
    for(i = 0; i < files_size; ++i) {
	assert(files[i]);

	/* load key */
	key = xmlSecCryptoAppPemKeyLoad(files[i], NULL, NULL, 0);
	if(key == NULL) {
    	    fprintf(stderr,"Error: failed to load public pem key from \"%s\"\n", files[i]);
	    xmlSecKeysMngrDestroy(mngr);
	    return(NULL);
	}

	/* set key name to the file name, this is just an example! */
	if(xmlSecKeySetName(key, BAD_CAST files[i]) < 0) {
    	    fprintf(stderr,"Error: failed to set key name for key from \"%s\"\n", files[i]);
	    xmlSecKeyDestroy(key);
	    xmlSecKeysMngrDestroy(mngr);
	    return(NULL);
	}
	
	/* add key to keys manager, from now on keys manager is responsible 
	 * for destroying key 
	 */
	if(xmlSecCryptoAppSimpleKeysMngrAdoptKey(mngr, key) < 0) {
    	    fprintf(stderr,"Error: failed to add key from \"%s\" to keys manager\n", files[i]);
	    xmlSecKeyDestroy(key);
	    xmlSecKeysMngrDestroy(mngr);
	    return(NULL);
	}
    }

    return(mngr);
}
		]]></programlisting>
		<simpara><link linkend="xmlsec-example-dsig4">Full program listing</link></simpara>
	    </example>
	</para>
	<para>
	     <example>
		<title>Initializing keys manager and loading DES keys from binary files.</title>
		<programlisting><![CDATA[
/**
 * load_des_keys:
 * @files:		the list of filenames.
 * @files_size:		the number of filenames in #files.
 *
 * Creates simple keys manager and load DES keys from #files in it.
 * The caller is responsible for destroing returned keys manager using
 * @xmlSecKeysMngrDestroy.
 *
 * Returns the pointer to newly created keys manager or NULL if an error
 * occurs.
 */
xmlSecKeysMngrPtr 
load_des_keys(char** files, int files_size) {
    xmlSecKeysMngrPtr mngr;
    xmlSecKeyPtr key;
    int i;
    
    assert(files);
    assert(files_size > 0);
    
    /* create and initialize keys manager, we use a simple list based
     * keys manager, implement your own xmlSecKeysStore klass if you need
     * something more sophisticated 
     */
    mngr = xmlSecKeysMngrCreate();
    if(mngr == NULL) {
	fprintf(stderr, "Error: failed to create keys manager.\n");
	return(NULL);
    }
    if(xmlSecCryptoAppSimpleKeysMngrInit(mngr) < 0) {
	fprintf(stderr, "Error: failed to initialize keys manager.\n");
	xmlSecKeysMngrDestroy(mngr);
	return(NULL);
    }    
    
    for(i = 0; i < files_size; ++i) {
	assert(files[i]);

	/* load DES key */
	key = xmlSecKeyReadBinaryFile(xmlSecKeyDataDesId, files[i]);
	if(key == NULL) {
    	    fprintf(stderr,"Error: failed to load des key from binary file \"%s\"\n", files[i]);
	    xmlSecKeysMngrDestroy(mngr);
	    return(NULL);
	}

	/* set key name to the file name, this is just an example! */
	if(xmlSecKeySetName(key, BAD_CAST files[i]) < 0) {
    	    fprintf(stderr,"Error: failed to set key name for key from \"%s\"\n", files[i]);
	    xmlSecKeyDestroy(key);
	    xmlSecKeysMngrDestroy(mngr);
	    return(NULL);
	}
	
	/* add key to keys manager, from now on keys manager is responsible 
	 * for destroying key 
	 */
	if(xmlSecCryptoAppSimpleKeysMngrAdoptKey(mngr, key) < 0) {
    	    fprintf(stderr,"Error: failed to add key from \"%s\" to keys manager\n", files[i]);
	    xmlSecKeyDestroy(key);
	    xmlSecKeysMngrDestroy(mngr);
	    return(NULL);
	}
    }

    return(mngr);
}
		]]></programlisting>
		<simpara><link linkend="xmlsec-example-enc4">Full program listing</link></simpara>
	    </example>
	</para>
    </sect2>

    <sect2>
	<title>Implementing a custom keys store.</title>
	<para>TODO</para>
	<para>
	     <example>
		<title>Creating a custom keys manager.</title>
		<programlisting><![CDATA[
/**
 * create_files_keys_mngr:
 *  
 * Creates a files based keys manager: we assume that key name is 
 * the key file name,
 *
 * Returns pointer to newly created keys manager or NULL if an error occurs.
 */
xmlSecKeysMngrPtr 
create_files_keys_mngr(void) {
    xmlSecKeyStorePtr keysStore;
    xmlSecKeysMngrPtr mngr;

    /* create files based keys store */
    keysStore = xmlSecKeyStoreCreate(files_keys_store_get_klass());
    if(keysStore == NULL) {
	fprintf(stderr, "Error: failed to create keys store.\n");
	return(NULL);
    }
    
    /* create keys manager */
    mngr = xmlSecKeysMngrCreate();
    if(mngr == NULL) {
	fprintf(stderr, "Error: failed to create keys manager.\n");
	xmlSecKeyStoreDestroy(keysStore);
	return(NULL);
    }

    /* add store to keys manager, from now on keys manager destroys the store if needed */
    if(xmlSecKeysMngrAdoptKeysStore(mngr, keysStore) < 0) {
	fprintf(stderr, "Error: failed to add keys store to keys manager.\n");
	xmlSecKeyStoreDestroy(keysStore);
	xmlSecKeysMngrDestroy(mngr);
	return(NULL);
    }
    
    /* initialize crypto library specific data in keys manager */
    if(xmlSecCryptoKeysMngrInit(mngr) < 0) {
	fprintf(stderr, "Error: failed to initialize crypto data in keys manager.\n");
	xmlSecKeysMngrDestroy(mngr);
	return(NULL);
    }

    /* set the get key callback */    
    mngr->getKey = xmlSecKeysMngrGetKey;
    return(mngr);
}

/****************************************************************************
 *
 * Files Keys Store: we assume that key's name (content of the 
 * <dsig:KeyName/> element is a name of the file with a key.
 * Attention: this probably not a good solution for high traffic systems.
 * 
 ***************************************************************************/
static int			files_keys_store_find_key	(xmlSecKeyStorePtr store,
								 xmlSecKeyPtr key,
								 const xmlChar* name,
								 xmlSecKeyInfoCtxPtr keyInfoCtx);
static xmlSecKeyStoreKlass files_keys_store_klass = {
    sizeof(xmlSecKeyStoreKlass),
    sizeof(xmlSecKeyStore),
    BAD_CAST "files-based-keys-store",	/* const xmlChar* name; */         
    NULL,				/* xmlSecKeyStoreInitializeMethod initialize; */
    NULL,				/* xmlSecKeyStoreFinalizeMethod finalize; */
    files_keys_store_find_key,		/* xmlSecKeyStoreFindMethod find; */

    /* reserved for the future */
    NULL,				/* void* reserved0; */
    NULL,				/* void* reserved1; */
};

/**
 * files_keys_store_get_klass:
 * 
 * The files based keys store klass: we assume that key name is the
 * key file name,
 *
 * Returns files based keys store klass.
 */
xmlSecKeyStoreId 
files_keys_store_get_klass(void) {
    return(&files_keys_store_klass);
}

/**
 * files_keys_store_find_key:
 * @store:		the pointer to simple keys store.
 * @name:		the desired key name.
 * @keyInfoCtx:		the pointer to <dsig:KeyInfo/> node processing context.
 *  
 * Lookups key in the @store.
 *
 * Returns pointer to key or NULL if key not found or an error occurs.
 */
static int
files_keys_store_find_key(xmlSecKeyStorePtr store,  xmlSecKeyPtr key, 
			const xmlChar* name, xmlSecKeyInfoCtxPtr keyInfoCtx) {
    xmlSecPtrListPtr list;
    xmlSecKeyPtr tmpKey = NULL;
    size_t pos, size;
    int ret;
    
    assert(store);
    assert(key);
    assert(keyInfoCtx);

    /* it's possible to do not have the key name or desired key type 
     * but we could do nothing in this case */
    if((name == NULL) || (keyInfoCtx->keyReq.keyId == xmlSecKeyDataIdUnknown)){
	return(0);
    }
    
    if((keyInfoCtx->keyReq.keyId == xmlSecKeyDataDsaId) || (keyInfoCtx->keyReq.keyId == xmlSecKeyDataRsaId)) {
	/* load key from a pem file, if key is not found then it's an error (is it?) */
	tmpKey = xmlSecCryptoAppPemKeyLoad(name, NULL, NULL, 0);
	if(tmpKey == NULL) {
    	    fprintf(stderr,"Error: failed to load public pem key from \"%s\"\n", name);
	    return(-1);
	}
    } else {
	/* otherwise it's a binary key, if key is not found then it's an error (is it?) */
	tmpKey = xmlSecKeyReadBinaryFile(keyInfoCtx->keyReq.keyId, name);
	if(tmpKey == NULL) {
    	    fprintf(stderr,"Error: failed to load des key from binary file \"%s\"\n", name);
	    return(-1);
	}

    }

    /* erase any current information in the key because we don't care
     * about the data in the <dsig:KeyInfo/> other than key name
     */
    xmlSecKeyEmpty(key);
    
    /* and copy the key from keys storage */
    ret = xmlSecKeyCopy(key, tmpKey);
    if(ret < 0) {
	fprintf(stderr, "Error: failed to copy key \"%s\"\n", name);
	xmlSecKeyDestroy(tmpKey);
	return(-1);
    }
    
    /* destroy our key */
    xmlSecKeyDestroy(tmpKey);

    /* set key name */
    if(xmlSecKeySetName(key, name) < 0) {
        fprintf(stderr,"Error: failed to set key name for key from \"%s\"\n", name);
        return(-1);	
    }

    return(0);
}
		]]></programlisting>
		<simpara><link linkend="xmlsec-example-enc5">Full program listing</link></simpara>
	    </example>
	</para>
    </sect2>    
</sect1>
